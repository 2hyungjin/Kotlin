# Kotlin
- 코틀린은 **간결하고 실용적**이며 **자바 코드와의 상호운용성**을 중시한다.
- 코틀린은 **정적 타입 지정 언어**이다. 정적 타입 지정 언어의 장점은 다음과 같다.
  - **성능** : 실행 시점에서 어떤 메소드를 호출할지 알아내는 과정이 필요 없어 메소드 호출이 더 빠르다.
  - **신뢰성** : 컴파일러가 프로그램의 정확성을 검증하여 오류를 줄인다.
  - **유지 보수성** : 코드에서 다루는 객체가 어떤 타입인지 첫 눈에 알 수 있기에 코드를 다루기 쉽게 한다.
  - **도구 지원** : 더 안전하게 리팩토링할 수 있고, 더 정확한 코드 완성기능을 제공할 수 있다.
- 코틀린의 컴파일러는 문맥을 고려하여 변수 타입을 자동으로 결정해준다. 이를 **타입 추론**이라고 부른다.

### 함수형 프로그래밍과 객체지향 프로그래밍

함수형 프로그래밍의 개념은 다음과 같다.

- **일급 객체인 함수** : 함수를 일반 값처럼 다룰 수 있다. 변수에 저장할 수 있고, 인자로 전달할 수 있으며, 함수에서 새로운 함수를 만들어 반환할 수 있다.
- **불변성** : 만들어지면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용하여 프로그램을 작성한다.
- **부수 효과 없음** : 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 환경에 상호작용하지 않는 순수 함수를 제공한다.

함수형 프로그래밍의 장점은 다음과 같다.

- **명령형 코드보다 간결하다.** 더 강력한 추상화를 할 수 있으며 이를 통해 코드의 중복을 막을 수 있다.
- **다중 스레드를 사용해도 안전하다.** 불변 데이터 구조를 사용하고 순수 함수를 적용한다면 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다.
- **테스트가 쉽다.** 순수 함수는 준비 코드(setup code) 없이 독립적으로 테스트할 수 있다.

코틀린은 다음과 같은 방식으로 함수형 프로그래밍을 지원한다.

- **함수 타입을 지원**하여 어떤 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수를 반환할 수 있다.
- **람다식을 지원**함에 따라 번거로운 준비 코드를 작성하지 않아도 된다.
- **데이터 클래스**는 불변적인 값 객체를 간편하게 만들 수 있는 구문을 제공한다.
- 코틀린 표준 라이브러리는 객체와 컬랙션을 함수형 스타일로 다룰 수 있는 **API를 제공**한다.

그렇다고 코틀린은 함수형 프로그래밍 방식을 강요하지는 않는다.

### 코틀린의 철학

코틀린은 **실용성, 간결성, 안전성, 상호운용성**의 철학을 갖는다.

#### 실용성

코틀린은 연구를 위한 언어가 아닌 실제 프로젝트를 목표로 만들어졌으며, 특정 프로그래밍 스타일이나 패러다임 사용을 강제하지 않는다.

#### 간결성

코틀린은 여러 가지 번거로운 준비 코드를 묵시적으로 제공하기 때문에 깔끔한 코드를 쓸 수 있다.

또한 다양한 표준 라이브러리를 제공하여 반복되거나 길어질 수 있는 코드를 함수 호출로 대신한다.

**코드가 간결하면 쓰는 데 시간이 덜 걸린다. 중요한 것은 읽는 데도 시간이 덜 걸린다는 점이다.**

#### 안전성

코틀린은 JVM에서 실행되기에 이미 상당한 안정성을 보유한다. 또한 컴파일 시점 검사를 통해 더 많은 오류를 방지한다. 

코틀린은 null이 될 수 없는 값을 추적하며, 실행 시점에 NullPointerException이 발생할 수 있는 연산을 금지한다.

또한 cast에 대해서도 검사하기 때문에 ClassCastException을 방지해주기도 한다.

#### 상호운용성

코틀린은 자바의 기존 라이브러리를 그대로 사용할 수 있다. 코틀린은 다중 언어 프로젝트를 완전히 지원하며 코틀린과 자바가 섞여 있어도 제대로 프로그램을 컴파일할 수 있다.

### 코틀린 코드 컴파일

코틀린 소스코드는 .kt 확장자로 저장된다. 코틀린 컴파일러는 자바 컴파일러와 마찬가지로 코틀린 소스코드를 분석하여 .class파일을 만들어낸다. 만들어진 .class파일은 개발 중인 애플리케이션에 맞는 표준 패키징 과정을 걸쳐 실행될 수 있다.
