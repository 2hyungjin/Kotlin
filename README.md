# Kotlin

코틀린에 대한 이해가 부족하고 더 **코틀린 다운 코드**를 짜고 싶어서 코틀린 컴파일러 개발자가 쓴  **"Kotlin In Action"** 책을 읽게 되었다.

밑의 내용은 이 책을 읽고 내가 이해하며 정리한 내용이며 더 자세한 내용은 책을 구입해 읽어보길 바란다.

- 코틀린은 **간결하고 실용적**이며 **자바 코드와의 상호운용성**을 중시한다.
- 코틀린은 **정적 타입 지정 언어**이다. 정적 타입 지정 언어의 장점은 다음과 같다.
  - **성능** : 실행 시점에서 어떤 메소드를 호출할지 알아내는 과정이 필요 없어 메소드 호출이 더 빠르다.
  - **신뢰성** : 컴파일러가 프로그램의 정확성을 검증하여 오류를 줄인다.
  - **유지 보수성** : 코드에서 다루는 객체가 어떤 타입인지 첫 눈에 알 수 있기에 코드를 다루기 쉽게 한다.
  - **도구 지원** : 더 안전하게 리팩토링할 수 있고, 더 정확한 코드 완성기능을 제공할 수 있다.
- 코틀린의 컴파일러는 문맥을 고려하여 변수 타입을 자동으로 결정해준다. 이를 **타입 추론**이라고 부른다.

### 함수형 프로그래밍과 객체지향 프로그래밍

함수형 프로그래밍의 개념은 다음과 같다.

- **일급 객체인 함수** : 함수를 일반 값처럼 다룰 수 있다. 변수에 저장할 수 있고, 인자로 전달할 수 있으며, 함수에서 새로운 함수를 만들어 반환할 수 있다.
- **불변성** : 만들어지면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용하여 프로그램을 작성한다.
- **부수 효과 없음** : 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 환경에 상호작용하지 않는 순수 함수를 제공한다.

함수형 프로그래밍의 장점은 다음과 같다.

- **명령형 코드보다 간결하다.** 더 강력한 추상화를 할 수 있으며 이를 통해 코드의 중복을 막을 수 있다.
- **다중 스레드를 사용해도 안전하다.** 불변 데이터 구조를 사용하고 순수 함수를 적용한다면 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다.
- **테스트가 쉽다.** 순수 함수는 준비 코드(setup code) 없이 독립적으로 테스트할 수 있다.

코틀린은 다음과 같은 방식으로 함수형 프로그래밍을 지원한다.

- **함수 타입을 지원**하여 어떤 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수를 반환할 수 있다.
- **람다식을 지원**함에 따라 번거로운 준비 코드를 작성하지 않아도 된다.
- **데이터 클래스**는 불변적인 값 객체를 간편하게 만들 수 있는 구문을 제공한다.
- 코틀린 표준 라이브러리는 객체와 컬랙션을 함수형 스타일로 다룰 수 있는 **API를 제공**한다.

그렇다고 코틀린은 함수형 프로그래밍 방식을 강요하지는 않는다.

### 코틀린의 철학

코틀린은 **실용성, 간결성, 안전성, 상호운용성**의 철학을 갖는다.

#### 실용성

코틀린은 연구를 위한 언어가 아닌 실제 프로젝트를 목표로 만들어졌으며, 특정 프로그래밍 스타일이나 패러다임 사용을 강제하지 않는다.

#### 간결성

코틀린은 여러 가지 번거로운 준비 코드를 묵시적으로 제공하기 때문에 깔끔한 코드를 쓸 수 있다.

또한 다양한 표준 라이브러리를 제공하여 반복되거나 길어질 수 있는 코드를 함수 호출로 대신한다.

**코드가 간결하면 쓰는 데 시간이 덜 걸린다. 중요한 것은 읽는 데도 시간이 덜 걸린다는 점이다.**

#### 안전성

코틀린은 JVM에서 실행되기에 이미 상당한 안정성을 보유한다. 또한 컴파일 시점 검사를 통해 더 많은 오류를 방지한다. 

코틀린은 null이 될 수 없는 값을 추적하며, 실행 시점에 NullPointerException이 발생할 수 있는 연산을 금지한다.

또한 cast에 대해서도 검사하기 때문에 ClassCastException을 방지해주기도 한다.

#### 상호운용성

코틀린은 자바의 기존 라이브러리를 그대로 사용할 수 있다. 코틀린은 다중 언어 프로젝트를 완전히 지원하며 코틀린과 자바가 섞여 있어도 제대로 프로그램을 컴파일할 수 있다.

### 코틀린 코드 컴파일

코틀린 소스코드는 .kt 확장자로 저장된다. 코틀린 컴파일러는 자바 컴파일러와 마찬가지로 코틀린 소스코드를 분석하여 .class파일을 만들어낸다. 만들어진 .class파일은 개발 중인 애플리케이션에 맞는 표준 패키징 과정을 걸쳐 실행될 수 있다.

## 코틀린 기초

코틀린의 기초적인 코드는 자바와 비슷한 흐름으로 짤 수 있다.

**하지만 이런 코드는 "코틀린 다운 코드"라고 부르기는 어렵다.**

### 함수와 변수

```kotlin
fun main(args: Array<String>) {
    println("Hello World")
}
```

- 함수는 fun 키워드를 사용한다
- 파라미터 뒤에 타입을 쓴다.
- **함수를 최상위 수준에 정의할 수 있다. (꼭 클래스 안에 넣어야 할 필요가 없다.)**
- **코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 쓸 수 있도록 래퍼를 제공한다 (ex: System.out.println -> println)**
- 줄 끝에 세미콜론을 붙이지 않아도 된다.

#### 함수

```kotlin
fun 이름(파라미터 : type) : 반환형(없으면 생략 가능){
  함수 바디
}
```

코틀린의 기본적인 함수 모양이다.

#### 문(statement)과 식(expression)의 구분

식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있지만 

문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상의 요소로 존재하며 아무런 값을 만들어 내지 않는다.

코틀린에서 if문 등의 제어 구조가 식이므로 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 자바는 문이기에 그렇지 못하다.

#### 식이 본문인 함수

```kotlin
fun max(a: Int, b: Int):Int=if(a>b) a else b
```

중괄호를 없애고 return 대신 =를 붙여 간결하게 함수를 표현할 수 있다.

본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라고 부르고

등호와 식으로 이루어진 함수를 **식이 본문인 함수**라고 한다.

식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 반환 타입을 정해준다. (타입 추론)

#### 변수

- val(value에서 따옴) : 변경 불가능한 값을 저장한다. (자바의 final)
- var(variable에서 따옴) : 변경 가능한 값을 저장한다.

기본적으로 val 키워드를 사용해 불변 변수로 선언하고, 변경이 필요할 때에 var로 변경하는 것이 좋다.

val 참조 자체가 불변이라도 참조가 가리키는 객체의 내부 값은 변경될 수 있다.

var 키워드를 사용하면 변수의 값을 변경할 수 있지만 타입은 바꿀 수 없다.

문자열 리터럴에 변수 앞에 $를 넣어 문자열 템플릿 기능을 사용할 수 있다. (변수의 값이 문자열 리터럴과 이어져 나온다.)

### 클래스와 프로퍼티

```kotlin
class Person(val name: String)
```

코드 없이 데이터만 저장하는 클래스를 값객체라고 부른다.

코틀린은 기본 가시성이 public이며 생략할 수 있다.

#### 프로퍼티

**클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것**이다.

자바에서는 필드를 private으로 생성하고 getter와 setter의 접근자 메소드를 활용하여 프로퍼티의 접근성을 제어하는데,

코틀린에선 이를 val과 var의 특징을 활용하여 제어한다.

```java
class Person{
  private String name;
  public String getName(){
    return this.name;
  }
  public void setName(String name){
    this.name=name;
  }
  //name은 읽기와 쓰기 모두 접근 가능한 프로퍼티이다.
  
  private int age;
  public int getAge(){
    return this.age
  }
  //age는 읽기만 가능한 read only 프로퍼티이다.
}
```

이 코드를 코틀린에서는

```kotlin
class Person(var name:String, val age:Int)
//name 읽기 쓰기 모두 접근 가능한 프로퍼티이고 age는 read only 프로퍼티이다.
```

이렇게 간단하게 사용할 수 있다.

#### 커스텀 접근자

```kotlin
class Person(val age: Int) {
    val availabilityOfDriving: Boolean
        get() = age > 19
}
```

위 코드의 Person 클래스는 getter를 자체 구현하는 코드이다.

Person 인스턴스가 availabilityOfDriving의 값을 읽으려하면 age에 따라 boolean값을 자동으로 반환한다.



---

> 출처 : Kotlin In Action(드미트리 제메로프, 스베트라나 이사코바)
